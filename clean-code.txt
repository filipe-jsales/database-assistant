Introdução: Princípios da Engenharia de Software, do livro de Robert C. Martin Código Limpo, adaptados para JavaScript. Este guia não se limita a estilos, mas busca oferecer orientações para criar código legível, reutilizável e refatorável em JavaScript. Embora os princípios não sejam leis rígidas, foram construídos ao longo de anos de experiência. A prática da engenharia de software é recente e ainda está em desenvolvimento. Portanto, esses princípios servem como guia para avaliar a qualidade do código JavaScript. Tenha em mente que aprender esses conceitos não garante perfeição imediata. Cada código começa como um rascunho, moldado e aprimorado ao longo do tempo. Trabalhe com esses princípios para aprimorar continuamente seu código.
Variáveis:Nomeação: Use nomes de variáveis significativos e pronunciáveis para facilitar a leitura e entendimento do código. Evite nomes sem significado, como yyyymmdstr, e prefira algo descritivo como currentDate.
Consistência de Vocabulário: Use o mesmo vocabulário para o mesmo tipo de variável. Exemplo: ao invés de getUserInfo(), getClientData(), e getCustomerRecord(), prefira um padrão único como getUser().
Nomes Pesquisáveis: Escrever código legível e pesquisável facilita a manutenção. Variáveis com nomes descritivos ajudam os leitores a entender melhor o programa. Ferramentas como buddy.js e ESLint auxiliam na identificação de constantes sem nome, como MILLISECONDS_PER_DAY, tornando o código mais compreensível.
Variáveis Explicativas e Mapeamento Mental: Use variáveis explicativas para descrever o propósito de valores complexos. Evite mapeamento mental excessivo; seja explícito em vez de implícito. Por exemplo, em vez de usar l para representar locations em um loop, use location para melhorar a clareza.
### Não adicione contextos desnecessários Se o nome de sua classe/objeto já lhe diz alguma coisa, não as repita nos nomes de suas variáveis. **Ruim:** ```javascript const Car = { carMake: 'Honda', carModel: 'Accord', carColor: 'Blue' }; function paintCar(car, color) { car.carColor = color; } ``` **Bom:** ```javascript const Car = { make: 'Honda', model: 'Accord', color: 'Blue' }; function paintCar(car, color) { car.color = color; } ``` ### Use argumentos padrões ao invés de curto circuitar ou usar condicionais Argumentos padrões são geralmente mais limpos do que curto circuitos. Esteja ciente que se você usá-los, sua função apenas irá fornecer valores padrões para argumentos `undefined`. Outros valores "falsos" como `''`, `""`, `false`, `null`, `0`, e `NaN`, não serão substituídos por valores padrões. **Ruim:** ```javascript function createMicrobrewery(name) { const breweryName = name || 'Hipster Brew Co.'; // ... } ``` **Bom:** ```javascript function createMicrobrewery(breweryName = 'Hipster Brew Co.') { // ... } ```
## **Funções** ### Argumentos de funções (idealmente 2 ou menos) Limitar a quantidade de parâmetros de uma função é incrivelmente importante porque torna mais fácil testá-la. Ter mais que três leva a uma explosão combinatória onde você tem que testar muitos casos diferentes com cada argumento separadamente. Um ou dois argumentos é o caso ideal, e três devem ser evitados se possível. Qualquer coisa a mais que isso deve ser consolidada. Geralmente, se você tem mais que dois argumentos então sua função está tentando fazer muitas coisas. Nos casos em que não está, na maioria das vezes um objeto é suficiente como argumento. Já que JavaScript lhe permite criar objetos instantaneamente, sem ter que escrever muita coisa, você pode usar um objeto se você se pegar precisando usar muitos argumentos. Para tornar mais óbvio quais as propriedades que as funções esperam, você pode usar a sintaxe de desestruturação (destructuring) do ES2015/ES6. Ela possui algumas vantagens: 1. Quando alguém olha para a assinatura de uma função, fica imediatamente claro quais propriedades são usadas. 2. Desestruturação também clona os valores primitivos específicos do objeto passado como argumento para a função. Isso pode ajudar a evitar efeitos colaterais. Nota: objetos e vetores que são desestruturados a partir do objeto passado por argumento NÃO são clonados. 3. Linters podem te alertar sobre propriedades não utilizadas, o que seria impossível sem usar desestruturação. **Ruim:** ```javascript function createMenu(title, body, buttonText, cancellable) { // ... } ``` **Bom:** ```javascript function createMenu({ title, body, buttonText, cancellable }) { // ... } createMenu({ title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true }); ```
### Funções devem fazer uma coisa Essa é de longe a regra mais importante em engenharia de software. Quando funções fazem mais que uma coisa, elas se tornam difíceis de serem compostas, testadas e raciocinadas. Quando você pode isolar uma função para realizar apenas uma ação, elas podem ser refatoradas facilmente e seu código ficará muito mais limpo. Se você não levar mais nada desse guia além disso, você já estará na frente de muitos desenvolvedores. **Ruim:** ```javascript function emailClients(clients) { clients.forEach((client) => { const clientRecord = database.lookup(client); if (clientRecord.isActive()) { email(client); } }); } ``` **Bom:** ```javascript function emailActiveClients(clients) { clients .filter(isActiveClient) .forEach(email); } function isActiveClient(client) { const clientRecord = database.lookup(client); return clientRecord.isActive(); } ``` ### Nomes de funções devem dizer o que elas fazem **Ruim:** ```javascript function addToDate(date, month) { // ... } const date = new Date(); // É difícil dizer pelo nome da função o que é adicionado addToDate(date, 1); ``` **Bom:** ```javascript function addMonthToDate(month, date) { // ... } const date = new Date(); addMonthToDate(1, date); ``` ### Funções devem ter apenas um nível de abstração Quando você tem mais de um nível de abstração sua função provavelmente esta fazendo coisas demais. Dividir suas funções leva a reutilização e testes mais fáceis. **Ruim:** ```javascript function parseBetterJSAlternative(code) { const REGEXES = [ // ... ]; const statements = code.split(' '); const tokens = []; REGEXES.forEach((REGEX) => { statements.forEach((statement) => { // ... }); }); const ast = []; tokens.forEach((token) => { // lex... }); ast.forEach((node) => { // parse... }); } ``` **Bom:** ```javascript function tokenize(code) { const REGEXES = [ // ... ]; const statements = code.split(' '); const tokens = []; REGEXES.forEach((REGEX) => { statements.forEach((statement) => { tokens.push( /* ... */ ); }); }); return tokens; } function lexer(tokens) { const ast = []; tokens.forEach((token) => { ast.push( /* ... */ ); }); return ast; } function parseBetterJSAlternative(code) { const tokens = tokenize(code); const ast = lexer(tokens); ast.forEach((node) => { // parse... }); } ```
